{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <div class="main">
        <h1>This is the report page</h1>
        <div id="kmom01"><h2>kmom01</h2></div>
        <p>Min mest omfattande kunskap och erfarenhet av objektorientering kommer från Oopython, där vi har arbetat med objektorientering under hela kursen. Under javascriptkursen förra hösten hade vi en snabb genomgång av objektorientering.</p>
        <p>För att komma igång med klasser i PHP är det viktigt att förstå att en klass fungerar som en mall för att skapa objekt. En klass definierar både egenskaper (variabler) och metoder (funktioner) för de objekt som skapas från den. Det är viktigt att notera att metoder delas mellan alla objekt som skapas från klassen, medan egenskaperna är individuella för varje objekt. Genom att förstå dessa grundläggande koncept kan man börja skapa sina första klasser och objekt i PHP.</p>
        <p>Kodbasen för uppgiften me/report är strukturerad med implementering av PHP, Symfony, Twig och Encore. Den är uppdelad i tre controllers för olika typer av begäranden: en för Twig-templates, en för JSON-respons och en för API-anrop. Symfony's routing och annotations används för att definiera vägar till respektive controllers, vilket ger en tydlig struktur. Separationen av controllers efter deras ansvarsområden underlättar underhåll och utökning av kodbasen. Twig-templates är utformade med separata block för olika delar av sidan, vilket möjliggör enkel återanvändning och modifiering av layouten.</p>
        <p>Baserat på artikeln "PHP The Right Way" finner jag flera delar extra intressanta och värdefulla. Speciellt avsnittet 'Coding Practices', särskilt 'The Basics', ger en solid grund för att både fräscha upp minnet och komma igång med lite mer avancerat PHP med fokus på objektorientering. 'Templating' är också en viktig del, särskilt med tanke på 'mvc'-kursen, och hjälper till att hantera mallar på ett effektivt sätt.</p>
        <p>Jag är också nyfiken på delar som 'Testing' och 'Server and Deployment', då de kan hjälpa mig att säkerställa kvaliteten hos en applikation och lära mig hur man distribuerar den.</p>
        <p>TIL (Today I Learned) för detta kursmoment är både objektorienteringens grundläggande koncept i PHP och det första steget i att implementera arkitekturen för Model-View-Controller (MVC) i PHP för att bygga en applikation.</p>
        <div id="kmom02"><h2>kmom02</h2></div>
        <p>Arv är ett koncept där en klass, kallad subklass, kan ärva egenskaper och metoder från en annan klass, kallad superklass. I PHP uppnås arv med hjälp av nyckelordet 'extends'. Komposition är en princip där en klass innehåller en instans av en annan klass. Komposition innebär en stark koppling mellan klasser. I PHP implementeras komposition genom att skapa en instans av en annan klass inom en klass. Interface definierar ett kontrakt för klasser som implementerar det. Det specificerar en uppsättning metoder som den implementerande klassen måste definiera. Olika klasser kan behandlas på samma sätt så länge de implementerar samma gränssnitt. Trait hjälper till med återanvändning av kod. Traits liknar klasser men kan inte instansieras på egen hand; de används för att utöka funktionaliteten hos klasser genom att lägga till metoder och egenskaper. Traits kan inkluderas i klasser med hjälp av nyckelordet 'use', vilket möjliggör att flera traits används i en enda klass.</p>
        <p>För att lösa uppgiften har jag beslutat mig för att skapa sex olika klasser: de tre rekommenderade klasserna, en ytterligare för grafikkort och två till för att hantera delen med 'deal': Player och Game. Jag är ganska nöjd med min implementation, men den kan förbättras. Till exempel skulle det vara bättre att skapa ett Card Interface istället för att ärva CardGraphic från Card. Dessutom tror jag att klasserna Game, Player och CardHand kan förbättras för att bli mer effektiva. Strukturen verkar ganska bra för att skapa ett kortspel med olika funktioner.</p>
        <p>Hittills har jag funnit att Symfony erbjuder en strukturerad ram att arbeta inom, vilket har underlättat organiseringen och hanteringen av koden. Resultatet är en mer modulär kod som är lättare att underhålla. Jag inser dock att jag bara har skrapat på ytan av vad Symfony har att erbjuda. Det ser jag fram emot att utforska vidare i mitt arbete med plattformen.</p>
        <p>Under detta kursmoment har jag lärt mig mer om arv, komposition och hantering av sessioner. Det har varit en bra repetition av kodstruktur med objektorientering genom att skapa ett spel som utnyttjar olika klasser och funktionaliteter.</p>
        <div id="kmom03"><h2>kmom03</h2></div>
        <p>Flödesdiagram har varit ovärderliga för att skapa en klar logik för hela spelens förlopp. Pseudokod har också varit en bra komplettering för att få en något mer avancerad struktur för koden.</p>
        <p>För att lösa uppgiften har jag återvänt till mina tidigare klasser och skapat en ny, som ärver från min tidigare Game-klass. Det kanske inte var det bästa tillvägagångssättet, det skulle kanske ha fungerat bättre att ha en separat klass för spellogiken som hanterar enbart spelet utan att ärva från Game. Jag behövde modifiera och skapa ytterligare metoder i mina tidigare klasser för att kunna lösa uppgiften utan att förstöra koden för Kortspel. Då insåg jag att min gamla implementation kanske inte var den mest flexibla, särskilt när det gäller Game som skapar en kortlek av grafiska eller vanliga kort genom att ta ett argument.</p>
        <p>Tyvärr hann jag inte arbeta med de extra kraven som involverar insatser av pengar, vilket var besvikande för mig.</p>
        <p>Symfony kan vara lite knepigt i vissa fall; den officiella dokumentationen är inte alltid helt tydlig, och för det mesta hittar jag svar på StackOverflow. Annars underlättar Symfony en hel del i koden.</p>
        <p>Det jag lärde mig under denna kursdel är framförallt type hinting, som jag använde i stor utsträckning med hjälp av PHPStan, skapandet av en helhetslogik för ett spel och objektorientering som jag fortfarande behöver öva mycket på, särskilt arv och komposition, vilket fortfarande kan vara lite krångligt för mig.</p>
        <div id="kmom04"><h2>kmom04</h2></div>
        <p>Jag upplevde att skriva kod för att testa annan kod med PHPUnit som en givande och effektiv process. Det gav mig möjlighet att noggrant granska min egen kodimplementering och struktur. För mig är PHPUnit ett användbart verktyg som är lätt att använda och ger tillförlitliga testresultat. Rent allmänt har min erfarenhet med PHPUnit varit positiv och det har bidragit till att förbättra min utvecklingsprocess.</p>
        <p>Jag uppnådde fullständig kodtäckning på 100%, vilket är bra. Men att nå 100% kodtäckning kräver inte bara att testerna finns, utan även att de är välformulerade och täcker alla tänkbara scenarier. Jag prioriterade att skriva relevanta testfall som testade varje del av min kod och dess metoder. Det var en utmaning att säkerställa att mina testfall var tillräckligt bra för att uppnå hög kodtäckning.</p>
        <p>Jag skulle säga att större delen av min kod är testbar, men det finns vissa delar som kan förbättras. Till exempel, vissa metoder i Game och GamePlay klasserna upprepar sig något, vilket kan minska testbarheten. En potentiell förbättring skulle vara att sammanföra dessa klasser och omstrukturera koden för att möjliggöra spel i både Card och Twenty One spel på ett mer enhetligt sätt.</p>
        <p>För att förbättra testbarheten av min kod gjorde jag en specifik ändring. Jag lade till en 'get'-metod i Game-klassen för att möjliggöra en mer omfattande testning av konstruktionen. Denna metod returnerar 'players'-arrayen och underlättar testningen av den delen av koden.</p>
        <p>Att ha testbar kod är en viktig del av att skriva snygg och ren kod, men det är inte en garanti i sig själv. Även om testbar kod kan indikera en viss nivå av struktur och tydlighet, är det inte en absolut indikator på snygghet och renhet. Det är möjligt att hitta sätt att testa kod genom att använda olika metoder, men enkelheten i att testa kan ändå indikera att koden är välskriven och lätt att förstå. Så medan testbarhet kan vara en faktor, är det inte den enda aspekten som definierar snygg och ren kod skulle jag säga.</p>
        <div id="kmom05"><h2>kmom05</h2></div>
        <p>Det gick i stort sett bra att arbeta igenom övningen med Symfony och Doctrine. Jag fann det lite utmanande att greppa exakt hur koncepten mellan databasen och objekten fungerar. Doctrine bidrog till att hålla koden organiserad och läsbar. Dock, på grund av Symfony-dokumentationens begränsning och svårigheten att navigera genom Doctrine-dokumentationen, tog det ibland lång tid att hitta de rätta svaren.</p>
        <p>Vid utformningen av min applikation strävade jag efter ett enkelt och intuitivt gränssnitt för att användaren skulle kunna navigera genom den smidigt med tydlig information.</p>
        <p>Arbetet med ORM i CRUD-flödet gick bra. Processen är i grunden enkel och minskar kodmängden, särskilt när man använder Doctrine Query Language. Dock kan detta leda till mindre insyn i databasens åtgärder jämfört med att skriva vanliga SQL-frågor.</p>
        <p>Min uppfattning om ORM hittills är ganska nyanserad. Å ena sidan har jag funnit det mycket fördelaktigt för att minska mängden manuellt skrivna SQL-frågor. Jämfört med andra metoder, såsom att skriva ren SQL eller använda lagrade procedurer, upplever jag att Doctrine ORM är mer abstrakt och intuitivt för vissa utvecklare, även om det kan sakna den finjusterade kontrollen som man får med manuellt skrivna frågor.</p>
        <p>Min insikt för detta kursmoment är naturligtvis ORM med Doctrine och dess användning.</p>
        <div id="kmom06"><h2>kmom06</h2></div>
        <p>Phpmetrics gav mig värdefulla insikter om kodens underhållbarhet, särskilt genom att identifiera klasser med låga Maintainability Index och hög komplexitet. Scrutinizer, å andra sidan, betonade vikten av att hantera issues och violations för att förbättra kodkvaliteten och stabiliteten.</p>
        <p>Integrationen av Scrutinizer var smidig, och jag uppskattade dess badges, som ger en snabb översikt över kodkvaliteten och täckningen. Efter första bygget visade Scrutinizer en code coverage på 24%, vilket pekar på behovet av att öka testtäckningen för att förbättra kodkvaliteten och minska risken för buggar.</p>
        <p>Min egen syn på kodkvalitet är att den är avgörande för att skapa robusta, underhållbara och läsbara program. Jag tror att kodkvalitet kan delvis mätas genom badges och metrics som används av verktyg som phpmetrics och Scrutinizer. Dessa ger en överblick, men det är också viktigt att ha en djupare förståelse för kodens struktur och konventioner för att upprätthålla hög kvalitet över tid.</p>
        <p>Min TIL (Today I Learned) för detta kmom är att aktivt arbeta med kodkvalitet genom verktyg som phpmetrics och Scrutinizer kan leda till betydande förbättringar i kodens läsbarhet, underhållbarhet och stabilitet.</p>
        <div id="kmom07/10"><h2>kmom07/10</h2></div>
        <h2>1.</h2>
        <h3>krav 1-3</h3>
        <p>För att ge projektsidorna en tydligt annorlunda stil och utseende jämfört med rapport-sidorna, skapade jag en ny stylesheet, project.css, och en ny basmall, base.html.twig, som laddar den nya stylesheeten. Detta gör att projektsidorna får en egen navigeringsmeny och unika stilar, vilket skiljer dem visuellt från rapport-sidorna.</p>
        <p>För att implementera Blackjack-spelet på ett organiserat sätt, skapade jag nya klasser och en ny struktur för koden. Användaren kan spela med en till tre händer mot banken. Jag valde att skriva om klasserna från grunden eftersom jag inte var nöjd med organisationen i kmom03. Jag skappade tre Controllers i src/Controller, ProjectMainController.php som hanterar routes i navbaren, ProjectBlackJackController.php med alla spel routes och ProjectApiController.php för Api routes.</p>
        <p>Min implementation består av sju huvudklasser som ligger i src/Project:<br>
        Card: Denna klass har en konstruktor med parametrarna suit och value. Den innehåller metoder för att hämta kortets värde, bildlänk och en metod för att vända kortet (mellan upp- och nedsida).<br>
        Deck: Konstruktoren initierar en kortlek med konstanter för suit och value, och den har en metod som returnerar alla kort i leken.<br>
        Shoe: Konstruktoren tar emot ett heltal som representerar antalet lekar i shoen. Den har metoder för att räkna antalet kort i shoen och för att dra ett kort.<br>
        Hand: Denna klass har en boolean-egenskap för blackjack, samt metoder för att sätta en insats, lägga till ett nytt kort och räkna handens värde.<br>
        Player: Innehåller metoder för att sätta spelarens namn, lägga till en ny hand, justera balans och återställa handens egenskaper.<br>
        Dealer: Konstruktoren initierar ett nytt hand-objekt för dealern.<br>
        Game: Denna klass innehåller alla logiska metoder för att spela Blackjack. Det är den enda klass som anropas från kontrollern.</p>
        <p>Implementationen gör att Game-klassen och användargränssnittet (UI) 'kommunicerar' via en gameState-egenskap som uppdateras av olika metoder. Detta gör att kontrollern kan köra rätt funktioner och att UI visar rätt knappar. Spelet börjar med att spelaren skriver sitt namn och väljer antal händer att spela med. Game-klassen kontrollerar att spelarens balans är tillräcklig för att spela så många händer. Därefter placeras insatserna för varje hand, två kort delas ut till varje hand, och ett öppet samt ett dolt kort delas ut till dealern. Spelet fortskrider med metoden playerAction som tar emot användarens input från UI. Metoden setTurn kontrollerar om nästa hand ska spelas eller om det är dealerns tur. När dealern är klar, beräknas vinsterna för varje hand med metoden countWin och spelarens nya balans uppdateras för nästa runda.</p>
        <p>Spelet vyn som ligger i templates/project består av åtta olika twig templates som bytas och updateras beroende på användaren request.</p>
        <p>För att uppnå en kodtäckning på 100% under docs/coverage (phpunit) för hela src/Project-mappen har jag skapat sex olika testklasser under tests/Project.</p>
        <h3>krav 4</h3>
        <p>För implementationen av API routes har jag valt fyra GET routes och en POST route. API routes byggs på en Game som initieras och sparas i session. Om ingen Game initieras visas en string meddelande.
        De fem routes i API är:<br>
        /proj/api/shoe som hämtar Shoe från Game sparat i session och vissa kort i en string format tillsamman med nummer av kort kvar i shoe.<br>
        /proj/api/state som hämtar Game State från Game sparat i session och vissa det i en string format.<br>
        /proj/api/player som hämtar Player och visa spelaren kort i en string format.<br>
        /proj/api/dealer som hämtar Dealer och visa dealer kort i en string format.<br>
        /proj/api/draw POST route som dra en kort från Shoe object sparat i session och returnera den i en string format.</p>
        <h3>krav 5</h3>
        <p>Jag har valt att använda en databas via ORM i form av en statistik-tabell. Du kan hitta tabellerna under proj/statistics. I databasen har jag skapat två tabeller: game_stats och player_stats. De två entiteterna är kopplade genom att en spelare kan ha flera spel och ett spel har en spelare, vilket jag har förklarat i texten under proj/about/database. Jag skapar nya game_stats och player_stats i BlackjackController och uppdaterar deras data under spelets gång så att man kan få uppdaterad statistik om spelet, spelarens vinster och insatser.</p>

        <p>I databaskursen arbetade vi direkt med SQL, vilket innebar att vi skrev frågor själva för att interagera med databasen. Detta gav oss full kontroll över exakt vilka operationer som utfördes, vilket var fördelaktigt för att optimera prestanda och förstå detaljerna i databasens funktioner. Vi lärde oss att designa databasscheman, skriva komplexa SQL-frågor och hantera transaktioner manuellt. Denna metod var särskilt användbar när vi behövde finjustera prestanda eller när vi arbetade med komplexa frågeställningar som kan vara svåra att uttrycka med högre abstraktioner.<br>
        I motsats till detta använder Object-Relational Mapping (ORM) ett högre abstraktionsnivå för att interagera med databasen. ORM möjliggör databasarbete med objektorienterade paradigmer, vilket ofta resulterar i kod som är lättare att förstå och underhålla. Processen förenklas i grunden och minskar kodmängden, särskilt när man använder Doctrine Query Language. Dock kan detta leda till mindre insyn i databasens åtgärder jämfört med att skriva vanliga SQL-frågor.<br>
        En nackdel med ORM är att det ibland kan generera mindre optimerad SQL-kod, vilket kan påverka prestandan negativt om det inte används korrekt. Eftersom ORM försöker generalisera databasoperationer kan det ibland skapa ineffektiva frågor. Dessutom kan abstraktionen gömma den underliggande komplexiteten, vilket kan göra det svårare att felsöka och förstå exakt vad som händer i databasen.<br>
        Både ORM och direkt SQL utför i grunden samma CRUD-operationer (Create, Read, Update, Delete) på databasen och kräver en grundläggande förståelse för databasdesign och relationshantering. Skillnaderna ligger främst i abstraktionsnivå och grad av kontroll: direkt SQL ger maximal kontroll och djup insikt, medan ORM erbjuder bekvämlighet och snabbare utvecklingstid, men med vissa kompromisser när det gäller optimeringsmöjligheter.</p>
        <h2>2.</h2>
        <p>Trots att jag valde att lämna in projektet efter inlämningsdatumet lyckades jag genomföra det med ansträngning. Det berodde på att planeringen för webbapplikationskursens projekt tog längre tid än förväntat. Jag ville se till att leverera en tillräckligt bra version av projektet för MVC-kursen, så jag valde att lämna in det för try 2. <br>
        Den mest komplicerade delen att implementera var min Game-klass, som hanterar hela spelets logik. Jag arbetade hårt för att säkerställa att koden flöt smidigt och att spelet bytte till rätt hand när en hand fick blackjack eller gick över 21 poäng (bust). Projektet var utmanande på många sätt och krävde noggrannhet och förståelse för olika koncept. Trots att vi hade arbetat med liknande uppgifter under kmom03, kände jag att jag gjorde framsteg och implementerade en mer avancerad spellogik.<br>
        Utöver implementationen var det också viktigt att hantera tester, API och ORM. Sammantaget var det en intensiv och komplett uppgift som var både utmanande och intressant att genomföra. Jag anser att projektet var väl anpassat till kursens krav och gav mig en djupare förståelse för MVC-arkitektur och webbutveckling.</p>
        <h2>3.</h2>
        <p>Jag tyckte att kursen var intressant och viktig för att utveckla våra förmågor inom objektorienterad programmering med PHP. Att lära sig hantera databaser på ett objektorienterat sätt med ORM var, även om det var lite krångligt till en början, en viktig kunskap att förvärva. Jag önskar att kursens övningar hade varit på en mer avancerad nivå för att ge oss möjlighet att lära oss mer om strukturering och testning, såsom tester för controllers eller databasåtkomst. Ibland kändes det som att det fanns en viss klyfta mellan övningarna och de faktiska uppgifterna.<br>
        Kommentarerna på våra arbeten var inte alltid så detaljerade eller kritiska, vilket gjorde att det kunde vara svårt att veta om man hade en optimal struktur och tillräckligt bra kodkvalitet. Trots detta skulle jag ändå rekommendera kursen till andra och ge den betyget 7 av 10.</p>

    </div>
{% endblock %}