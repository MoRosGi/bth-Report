{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <div class="main">
        <div class="container">
            <h1>This is the report page</h1>
            <div id="kmom01"><h2>kmom01</h2></div>
            <p>Min mest omfattande kunskap och erfarenhet av objektorientering kommer från Oopython, där vi har arbetat med objektorientering under hela kursen. Under javascriptkursen förra hösten hade vi en snabb genomgång av objektorientering.</p>
            <p>För att komma igång med klasser i PHP är det viktigt att förstå att en klass fungerar som en mall för att skapa objekt. En klass definierar både egenskaper (variabler) och metoder (funktioner) för de objekt som skapas från den. Det är viktigt att notera att metoder delas mellan alla objekt som skapas från klassen, medan egenskaperna är individuella för varje objekt. Genom att förstå dessa grundläggande koncept kan man börja skapa sina första klasser och objekt i PHP.</p>
            <p>Kodbasen för uppgiften me/report är strukturerad med implementering av PHP, Symfony, Twig och Encore. Den är uppdelad i tre controllers för olika typer av begäranden: en för Twig-templates, en för JSON-respons och en för API-anrop. Symfony's routing och annotations används för att definiera vägar till respektive controllers, vilket ger en tydlig struktur. Separationen av controllers efter deras ansvarsområden underlättar underhåll och utökning av kodbasen. Twig-templates är utformade med separata block för olika delar av sidan, vilket möjliggör enkel återanvändning och modifiering av layouten.</p>
            <p>Baserat på artikeln "PHP The Right Way" finner jag flera delar extra intressanta och värdefulla. Speciellt avsnittet 'Coding Practices', särskilt 'The Basics', ger en solid grund för att både fräscha upp minnet och komma igång med lite mer avancerat PHP med fokus på objektorientering. 'Templating' är också en viktig del, särskilt med tanke på 'mvc'-kursen, och hjälper till att hantera mallar på ett effektivt sätt.</p>
            <p>Jag är också nyfiken på delar som 'Testing' och 'Server and Deployment', då de kan hjälpa mig att säkerställa kvaliteten hos en applikation och lära mig hur man distribuerar den.</p>
            <p>TIL (Today I Learned) för detta kursmoment är både objektorienteringens grundläggande koncept i PHP och det första steget i att implementera arkitekturen för Model-View-Controller (MVC) i PHP för att bygga en applikation.</p>
            <div id="kmom02"><h2>kmom02</h2></div>
            <p>Arv är ett koncept där en klass, kallad subklass, kan ärva egenskaper och metoder från en annan klass, kallad superklass. I PHP uppnås arv med hjälp av nyckelordet 'extends'. Komposition är en princip där en klass innehåller en instans av en annan klass. Komposition innebär en stark koppling mellan klasser. I PHP implementeras komposition genom att skapa en instans av en annan klass inom en klass. Interface definierar ett kontrakt för klasser som implementerar det. Det specificerar en uppsättning metoder som den implementerande klassen måste definiera. Olika klasser kan behandlas på samma sätt så länge de implementerar samma gränssnitt. Trait hjälper till med återanvändning av kod. Traits liknar klasser men kan inte instansieras på egen hand; de används för att utöka funktionaliteten hos klasser genom att lägga till metoder och egenskaper. Traits kan inkluderas i klasser med hjälp av nyckelordet 'use', vilket möjliggör att flera traits används i en enda klass.</p>
            <p>För att lösa uppgiften har jag beslutat mig för att skapa sex olika klasser: de tre rekommenderade klasserna, en ytterligare för grafikkort och två till för att hantera delen med 'deal': Player och Game. Jag är ganska nöjd med min implementation, men den kan förbättras. Till exempel skulle det vara bättre att skapa ett Card Interface istället för att ärva CardGraphic från Card. Dessutom tror jag att klasserna Game, Player och CardHand kan förbättras för att bli mer effektiva. Strukturen verkar ganska bra för att skapa ett kortspel med olika funktioner.</p>
            <p>Hittills har jag funnit att Symfony erbjuder en strukturerad ram att arbeta inom, vilket har underlättat organiseringen och hanteringen av koden. Resultatet är en mer modulär kod som är lättare att underhålla. Jag inser dock att jag bara har skrapat på ytan av vad Symfony har att erbjuda. Det ser jag fram emot att utforska vidare i mitt arbete med plattformen.</p>
            <p>Under detta kursmoment har jag lärt mig mer om arv, komposition och hantering av sessioner. Det har varit en bra repetition av kodstruktur med objektorientering genom att skapa ett spel som utnyttjar olika klasser och funktionaliteter.</p>
            <div id="kmom03"><h2>kmom03</h2></div>
            <p>Flödesdiagram har varit ovärderliga för att skapa en klar logik för hela spelens förlopp. Pseudokod har också varit en bra komplettering för att få en något mer avancerad struktur för koden.</p>
            <p>För att lösa uppgiften har jag återvänt till mina tidigare klasser och skapat en ny, som ärver från min tidigare Game-klass. Det kanske inte var det bästa tillvägagångssättet, det skulle kanske ha fungerat bättre att ha en separat klass för spellogiken som hanterar enbart spelet utan att ärva från Game. Jag behövde modifiera och skapa ytterligare metoder i mina tidigare klasser för att kunna lösa uppgiften utan att förstöra koden för Kortspel. Då insåg jag att min gamla implementation kanske inte var den mest flexibla, särskilt när det gäller Game som skapar en kortlek av grafiska eller vanliga kort genom att ta ett argument.</p>
            <p>Tyvärr hann jag inte arbeta med de extra kraven som involverar insatser av pengar, vilket var besvikande för mig.</p>
            <p>Symfony kan vara lite knepigt i vissa fall; den officiella dokumentationen är inte alltid helt tydlig, och för det mesta hittar jag svar på StackOverflow. Annars underlättar Symfony en hel del i koden.</p>
            <p>Det jag lärde mig under denna kursdel är framförallt type hinting, som jag använde i stor utsträckning med hjälp av PHPStan, skapandet av en helhetslogik för ett spel och objektorientering som jag fortfarande behöver öva mycket på, särskilt arv och komposition, vilket fortfarande kan vara lite krångligt för mig.</p>
            <div id="kmom04"><h2>kmom04</h2></div>
            <p>Jag upplevde att skriva kod för att testa annan kod med PHPUnit som en givande och effektiv process. Det gav mig möjlighet att noggrant granska min egen kodimplementering och struktur. För mig är PHPUnit ett användbart verktyg som är lätt att använda och ger tillförlitliga testresultat. Rent allmänt har min erfarenhet med PHPUnit varit positiv och det har bidragit till att förbättra min utvecklingsprocess.</p>
            <p>Jag uppnådde fullständig kodtäckning på 100%, vilket är bra. Men att nå 100% kodtäckning kräver inte bara att testerna finns, utan även att de är välformulerade och täcker alla tänkbara scenarier. Jag prioriterade att skriva relevanta testfall som testade varje del av min kod och dess metoder. Det var en utmaning att säkerställa att mina testfall var tillräckligt bra för att uppnå hög kodtäckning.</p>
            <p>Jag skulle säga att större delen av min kod är testbar, men det finns vissa delar som kan förbättras. Till exempel, vissa metoder i Game och GamePlay klasserna upprepar sig något, vilket kan minska testbarheten. En potentiell förbättring skulle vara att sammanföra dessa klasser och omstrukturera koden för att möjliggöra spel i både Card och Twenty One spel på ett mer enhetligt sätt.</p>
            <p>För att förbättra testbarheten av min kod gjorde jag en specifik ändring. Jag lade till en 'get'-metod i Game-klassen för att möjliggöra en mer omfattande testning av konstruktionen. Denna metod returnerar 'players'-arrayen och underlättar testningen av den delen av koden.</p>
            <p>Att ha testbar kod är en viktig del av att skriva snygg och ren kod, men det är inte en garanti i sig själv. Även om testbar kod kan indikera en viss nivå av struktur och tydlighet, är det inte en absolut indikator på snygghet och renhet. Det är möjligt att hitta sätt att testa kod genom att använda olika metoder, men enkelheten i att testa kan ändå indikera att koden är välskriven och lätt att förstå. Så medan testbarhet kan vara en faktor, är det inte den enda aspekten som definierar snygg och ren kod skulle jag säga.</p>
            <div id="kmom05"><h2>kmom05</h2></div>
            <p>Det gick i stort sett bra att arbeta igenom övningen med Symfony och Doctrine. Jag fann det lite utmanande att greppa exakt hur koncepten mellan databasen och objekten fungerar. Doctrine bidrog till att hålla koden organiserad och läsbar. Dock, på grund av Symfony-dokumentationens begränsning och svårigheten att navigera genom Doctrine-dokumentationen, tog det ibland lång tid att hitta de rätta svaren.</p>
            <p>Vid utformningen av min applikation strävade jag efter ett enkelt och intuitivt gränssnitt för att användaren skulle kunna navigera genom den smidigt med tydlig information.</p>
            <p>Arbetet med ORM i CRUD-flödet gick bra. Processen är i grunden enkel och minskar kodmängden, särskilt när man använder Doctrine Query Language. Dock kan detta leda till mindre insyn i databasens åtgärder jämfört med att skriva vanliga SQL-frågor.</p>
            <p>Min uppfattning om ORM hittills är ganska nyanserad. Å ena sidan har jag funnit det mycket fördelaktigt för att minska mängden manuellt skrivna SQL-frågor. Jämfört med andra metoder, såsom att skriva ren SQL eller använda lagrade procedurer, upplever jag att Doctrine ORM är mer abstrakt och intuitivt för vissa utvecklare, även om det kan sakna den finjusterade kontrollen som man får med manuellt skrivna frågor.</p>
            <p>Min insikt för detta kursmoment är naturligtvis ORM med Doctrine och dess användning.</p>
        </div>
    </div>
{% endblock %}